

// ===================================================================================================
//  This file is generated by build.rs. DO NOT EDIT
// ===================================================================================================

use crate::{addressing::AddressingMode, cpu::CPU, ops::{opcode::Operation,load_ops::*,store_ops::*,reg_ops::*,bit_ops::*,branch_ops::*,stack_ops::*,status_ops::*}};

/// ADd with Carry
pub mod ADC {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0x69, adc, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x65, adc, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x75, adc, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x6D, adc, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x7D, adc, 4, 1, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0x79, adc, 4, 1, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0x61, adc, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0x71, adc, 5, 1, AddressingMode::IndirectY);
 }
}

/// bitwise AND with accumulator
pub mod AND {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0x29, and, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x25, and, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x35, and, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x2D, and, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x3D, and, 4, 1, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0x39, and, 4, 1, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0x21, and, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0x31, and, 5, 1, AddressingMode::IndirectY);
 }
}

/// Arithmatic Shift Left
pub mod ASL {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x0A, asl, 2, 0, AddressingMode::Implied);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x06, asl, 5, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x16, asl, 6, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x0E, asl, 6, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x1E, asl, 7, 0, AddressingMode::AbsoluteX);
 }
}

/// test BITs
pub mod BIT {
 use super::*;

 lazy_static! {
   pub static ref ZERO_PAGE: Operation = Operation::new(0x24, bit, 3, 0, AddressingMode::ZeroPage);
   pub static ref ABSOLUTE: Operation = Operation::new(0x2C, bit, 4, 0, AddressingMode::Absolute);
 }
}

/// Branch on PLus
pub mod BPL {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x10, bpl, 2, 1, AddressingMode::Implied);
 }
}

/// Branch on MInus
pub mod BMI {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x30, bmi, 2, 1, AddressingMode::Implied);
 }
}

/// Branch on oVerflow Clear
pub mod BVC {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x50, bvc, 2, 1, AddressingMode::Implied);
 }
}

/// Branch on oVerflow Set
pub mod BVS {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x70, bvs, 2, 1, AddressingMode::Implied);
 }
}

/// Branch on Carry Clear
pub mod BCC {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x90, bcc, 2, 1, AddressingMode::Implied);
 }
}

/// Branch on Carry Set
pub mod BCS {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xB0, bcs, 2, 1, AddressingMode::Implied);
 }
}

/// Branch on Not Equal
pub mod BNE {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xD0, bne, 2, 1, AddressingMode::Implied);
 }
}

/// Branch on EQual
pub mod BEQ {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xF0, beq, 2, 1, AddressingMode::Implied);
 }
}

/// BReaK
pub mod BRK {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x00, brk, 7, 0, AddressingMode::Implied);
 }
}

/// CoMPare accumulator
pub mod CMP {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0xC9, cmp, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0xC5, cmp, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0xD5, cmp, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0xCD, cmp, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0xDD, cmp, 4, 1, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0xD9, cmp, 4, 1, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0xC1, cmp, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0xD1, cmp, 5, 1, AddressingMode::IndirectY);
 }
}

/// ComPare X register
pub mod CPX {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0xE0, cpx, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0xE4, cpx, 3, 0, AddressingMode::ZeroPage);
   pub static ref ABSOLUTE: Operation = Operation::new(0xEC, cpx, 4, 0, AddressingMode::Absolute);
 }
}

/// ComPare Y register
pub mod CPY {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0xC0, cpy, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0xC4, cpy, 3, 0, AddressingMode::ZeroPage);
   pub static ref ABSOLUTE: Operation = Operation::new(0xCC, cpy, 4, 0, AddressingMode::Absolute);
 }
}

/// DECrement memory
pub mod DEC {
 use super::*;

 lazy_static! {
   pub static ref ZERO_PAGE: Operation = Operation::new(0xC6, dec, 5, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0xD6, dec, 6, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0xCE, dec, 6, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0xDE, dec, 7, 0, AddressingMode::AbsoluteX);
 }
}

/// bitwise Exclusive OR
pub mod EOR {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0x49, eor, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x45, eor, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x55, eor, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x4D, eor, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x5D, eor, 4, 1, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0x59, eor, 4, 1, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0x41, eor, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0x51, eor, 5, 1, AddressingMode::IndirectY);
 }
}

/// CLear Carry
pub mod CLC {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x18, clc, 2, 0, AddressingMode::Implied);
 }
}

/// SEt Carry
pub mod SEC {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x38, sec, 2, 0, AddressingMode::Implied);
 }
}

/// CLear Interrupt
pub mod CLI {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x58, cli, 2, 0, AddressingMode::Implied);
 }
}

/// SEt Interrupt
pub mod SEI {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x78, sei, 2, 0, AddressingMode::Implied);
 }
}

/// CLear oVerflow
pub mod CLV {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xB8, clv, 2, 0, AddressingMode::Implied);
 }
}

/// CLear Decimal
pub mod CLD {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xD8, cld, 2, 0, AddressingMode::Implied);
 }
}

/// SEt Decimal
pub mod SED {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xF8, sed, 2, 0, AddressingMode::Implied);
 }
}

/// INCrement memory
pub mod INC {
 use super::*;

 lazy_static! {
   pub static ref ZERO_PAGE: Operation = Operation::new(0xE6, inc, 5, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0xF6, inc, 6, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0xEE, inc, 6, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0xFE, inc, 7, 0, AddressingMode::AbsoluteX);
 }
}

/// JuMP
pub mod JMP {
 use super::*;

 lazy_static! {
   pub static ref ABSOLUTE: Operation = Operation::new(0x4C, jmp, 3, 0, AddressingMode::Absolute);
   pub static ref INDIRECT: Operation = Operation::new(0x6C, jmp, 5, 0, AddressingMode::Indirect);
 }
}

/// Jump to SubRoutine
pub mod JSR {
 use super::*;

 lazy_static! {
   pub static ref ABSOLUTE: Operation = Operation::new(0x20, jsr, 6, 0, AddressingMode::Absolute);
 }
}

/// LoaD Accumulator
pub mod LDA {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0xA9, lda, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0xA5, lda, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0xB5, lda, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0xAD, lda, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0xBD, lda, 4, 1, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0xB9, lda, 4, 1, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0xA1, lda, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0xB1, lda, 5, 1, AddressingMode::IndirectY);
 }
}

/// LoaD X register
pub mod LDX {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0xA2, ldx, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0xA6, ldx, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_Y: Operation = Operation::new(0xB6, ldx, 4, 0, AddressingMode::ZeroPageY);
   pub static ref ABSOLUTE: Operation = Operation::new(0xAE, ldx, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0xBE, ldx, 4, 1, AddressingMode::AbsoluteY);
 }
}

/// LoaD Y register
pub mod LDY {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0xA0, ldy, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0xA4, ldy, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0xB4, ldy, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0xAC, ldy, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0xBC, ldy, 4, 1, AddressingMode::AbsoluteX);
 }
}

/// Logical Shift Right
pub mod LSR {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x4A, lsr, 2, 0, AddressingMode::Implied);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x46, lsr, 5, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x56, lsr, 6, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x4E, lsr, 6, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x5E, lsr, 7, 0, AddressingMode::AbsoluteX);
 }
}

/// No OPeration
pub mod NOP {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xEA, nop, 2, 0, AddressingMode::Implied);
 }
}

/// bitwise OR with Accumulator
pub mod ORA {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0x09, ora, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x05, ora, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x15, ora, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x0D, ora, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x1D, ora, 4, 1, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0x19, ora, 4, 1, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0x01, ora, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0x11, ora, 5, 1, AddressingMode::IndirectY);
 }
}

/// Transfer Accumulator to X
pub mod TAX {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xAA, tax, 2, 0, AddressingMode::Implied);
 }
}

/// Transfer X to Accumulator
pub mod TXA {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x8A, txa, 2, 0, AddressingMode::Implied);
 }
}

/// DEcrement X
pub mod DEX {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xCA, dex, 2, 0, AddressingMode::Implied);
 }
}

/// INcrement X
pub mod INX {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xE8, inx, 2, 0, AddressingMode::Implied);
 }
}

/// Transfer Accumulator to Y
pub mod TAY {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xA8, tay, 2, 0, AddressingMode::Implied);
 }
}

/// Transfer Y to Accumulator
pub mod TYA {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x98, tya, 2, 0, AddressingMode::Implied);
 }
}

/// DEcrement Y
pub mod DEY {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x88, dey, 2, 0, AddressingMode::Implied);
 }
}

/// INcrement Y
pub mod INY {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xC8, iny, 2, 0, AddressingMode::Implied);
 }
}

/// ROtate Left
pub mod ROL {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x2A, rol, 2, 0, AddressingMode::Implied);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x26, rol, 5, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x36, rol, 6, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x2E, rol, 6, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x3E, rol, 7, 0, AddressingMode::AbsoluteX);
 }
}

/// ROtate Right
pub mod ROR {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x6A, ror, 2, 0, AddressingMode::Implied);
   pub static ref ZERO_PAGE: Operation = Operation::new(0x66, ror, 5, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x76, ror, 6, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x6E, ror, 6, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x7E, ror, 7, 0, AddressingMode::AbsoluteX);
 }
}

/// ReTurn from Interrupt
pub mod RTI {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x40, rti, 6, 0, AddressingMode::Implied);
 }
}

/// ReTurn from Subroutine
pub mod RTS {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x60, rts, 6, 0, AddressingMode::Implied);
 }
}

/// SuBtract with Carry
pub mod SBC {
 use super::*;

 lazy_static! {
   pub static ref IMMEDIATE: Operation = Operation::new(0xE9, sbc, 2, 0, AddressingMode::Immediate);
   pub static ref ZERO_PAGE: Operation = Operation::new(0xE5, sbc, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0xF5, sbc, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0xED, sbc, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0xFD, sbc, 4, 1, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0xF9, sbc, 4, 1, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0xE1, sbc, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0xF1, sbc, 5, 1, AddressingMode::IndirectY);
 }
}

/// STore Accumulator
pub mod STA {
 use super::*;

 lazy_static! {
   pub static ref ZERO_PAGE: Operation = Operation::new(0x85, sta, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x95, sta, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x8D, sta, 4, 0, AddressingMode::Absolute);
   pub static ref ABSOLUTE_X: Operation = Operation::new(0x9D, sta, 5, 0, AddressingMode::AbsoluteX);
   pub static ref ABSOLUTE_Y: Operation = Operation::new(0x99, sta, 5, 0, AddressingMode::AbsoluteY);
   pub static ref INDIRECT_X: Operation = Operation::new(0x81, sta, 6, 0, AddressingMode::IndirectX);
   pub static ref INDIRECT_Y: Operation = Operation::new(0x91, sta, 6, 0, AddressingMode::IndirectY);
 }
}

/// Transfer X to Stack ptr
pub mod TXS {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x9A, txs, 2, 0, AddressingMode::Implied);
 }
}

/// Transfer Stack ptr to X
pub mod TSX {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0xBA, tsx, 2, 0, AddressingMode::Implied);
 }
}

/// PusH Accumulator
pub mod PHA {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x48, pha, 3, 0, AddressingMode::Implied);
 }
}

/// PuLl Accumulator
pub mod PLA {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x68, pla, 4, 0, AddressingMode::Implied);
 }
}

/// PusH Processor status
pub mod PHP {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x08, php, 3, 0, AddressingMode::Implied);
 }
}

/// PuLl Processor status
pub mod PLP {
 use super::*;

 lazy_static! {
   pub static ref IMPLIED: Operation = Operation::new(0x28, plp, 4, 0, AddressingMode::Implied);
 }
}

/// STore X register
pub mod STX {
 use super::*;

 lazy_static! {
   pub static ref ZERO_PAGE: Operation = Operation::new(0x86, stx, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_Y: Operation = Operation::new(0x96, stx, 4, 0, AddressingMode::ZeroPageY);
   pub static ref ABSOLUTE: Operation = Operation::new(0x8E, stx, 4, 0, AddressingMode::Absolute);
 }
}

/// STore Y register
pub mod STY {
 use super::*;

 lazy_static! {
   pub static ref ZERO_PAGE: Operation = Operation::new(0x84, sty, 3, 0, AddressingMode::ZeroPage);
   pub static ref ZERO_PAGE_X: Operation = Operation::new(0x94, sty, 4, 0, AddressingMode::ZeroPageX);
   pub static ref ABSOLUTE: Operation = Operation::new(0x8C, sty, 4, 0, AddressingMode::Absolute);
 }
}

