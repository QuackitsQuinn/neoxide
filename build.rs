use std::io::Write;

use json::JsonValue;

const HEADER: &str = r#"

// ===================================================================================================
//  This file is generated by build.rs. DO NOT EDIT
// ===================================================================================================

use crate::{addressing::AddressingMode, cpu::CPU, ops::{opcode::Operation,load_ops::*,store_ops::*,reg_ops::*,bit_ops::*,branch_ops::*,stack_ops::*,status_ops::*}};

"#;
#[derive(Debug)]
struct Op {
    code: u8,
    cycles: u8,
    page_cross_incr: u8,
    addressing_mode: String, // enum is in project but cant be used from build script
    addressing_mode_const: String,
}

impl From<&JsonValue> for Op {
    fn from(value: &JsonValue) -> Self {
        // empty return because switching json file structure
        // convert CAP_CASE to PascalCase
        let mut mode = String::new();
        for word in value["addr_mode"].as_str().unwrap().split("_") {
            mode.push_str(&word[..1].to_uppercase());
            mode.push_str(&word[1..].to_lowercase());
        }
        Self {
            code: value["opcode"].as_u8().unwrap(),
            cycles: value["cycles"].as_u8().unwrap(),
            page_cross_incr: value["page_cross_incr"].as_u8().unwrap(),
            addressing_mode: mode,
            addressing_mode_const: value["addr_mode"].as_str().unwrap().to_owned(),
        }
    }
}
#[derive(Debug)]
struct JsonOp {
    name: String,
    doc: String,
    ops: Vec<Op>,
}

impl JsonOp {
    fn new(name: &str, doc: &str, ops: Vec<Op>) -> Self {
        Self {
            name: name.to_owned(),
            doc: doc.to_owned(),
            ops,
        }
    }
    fn to_code(&self) -> String {
        let mut code = String::new();
        code.push_str(&format!("/// {}\n", self.doc));
        code.push_str(&format!("pub mod {} {{\n", self.name.to_uppercase()));
        code.push_str(" use super::*;\n\n");
        code.push_str(" lazy_static! {\n");
        for op in &self.ops {
            code.push_str(&format!("   pub static ref {}: Operation = Operation::new({:#04X?}, {}, {}, {}, AddressingMode::{});\n", op.addressing_mode_const, op.code, self.name.to_lowercase(), op.cycles, op.page_cross_incr, op.addressing_mode));
        }
        code.push_str(" }\n}\n\n");
        code = code.replace(r"\n", "\n");
        code
    }
}

impl From<&JsonValue> for JsonOp {
    fn from(value: &JsonValue) -> Self {
        let name = value["name"].as_str().unwrap();
        let doc = value["long_name"].as_str().unwrap();
        let mut ops: Vec<Op> = Vec::new();
        for mode in value["operands"].members() {
            let op: Op = mode.into();
            ops.push(op);
        }
        Self::new(name, doc, ops)
    }
}
// generates the code for the nes opcodes
fn main() {
    // return if opcodes.rs exists
    if !std::path::Path::new("src/ops/opcodes.rs").exists() {
        return; // uncomment this to prevent overwriting opcodes.rs
    }
    let mut codefile = std::fs::File::create("src/ops/opcodes.rs").unwrap();
    let mut code = String::from(HEADER);
    let ops = json::parse(include_str!("res/6502.json")).unwrap();
    let mut code_ops: Vec<JsonOp> = Vec::new();
    for op in ops.members() {
        let op: JsonOp = op.into();
        code_ops.push(op);
    }
    
    for op in code_ops {
        code.push_str(&op.to_code());
    }
    
    let res = codefile.write_all(code.as_bytes());
    match res {
        Ok(_) => println!("opcodes.rs generated"),
        Err(e) => println!("Error: {}", e),
    }
}
